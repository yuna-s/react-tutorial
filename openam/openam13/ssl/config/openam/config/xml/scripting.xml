<?xml version="1.0" encoding="UTF-8"?>
<!--
 * The contents of this file are subject to the terms of the Common Development and
 * Distribution License (the License). You may not use this file except in compliance with the
 * License.
 *
 * You can obtain a copy of the License at legal/CDDLv1.0.txt. See the License for the
 * specific language governing permission and limitations under the License.
 *
 * When distributing Covered Software, include this CDDL Header Notice in each file and include
 * the License file at legal/CDDLv1.0.txt. If applicable, add the following below the CDDL
 * Header, with the fields enclosed by brackets [] replaced by your own identifying
 * information: "Portions copyright [year] [name of copyright owner]".
 *
 * Copyright 2015-2016 ForgeRock AS.
-->
<!DOCTYPE ServicesConfiguration
    PUBLIC "=//iPlanet//Service Management Services (SMS) 1.0 DTD//EN" "jar://com/sun/identity/sm/sms.dtd">

<ServicesConfiguration>
    <Service name="ScriptingService" version="1.0">

        <Schema serviceHierarchy="/DSAMEConfig/ScriptingService"
                i18nFileName="scripting"
                revisionNumber="1"
                i18nKey="service-description"
                resourceName="scripting">
            <Global>
                <AttributeSchema name="defaultScriptContext" i18nKey="g101" type="single_choice"
                                 resourceName="defaultContext">
                    <ChoiceValues>
                        <ChoiceValue i18nKey="script-type-01">POLICY_CONDITION</ChoiceValue>
                        <ChoiceValue i18nKey="script-type-02">AUTHENTICATION_SERVER_SIDE</ChoiceValue>
                        <ChoiceValue i18nKey="script-type-03">AUTHENTICATION_CLIENT_SIDE</ChoiceValue>
                        <ChoiceValue i18nKey="script-type-04">OIDC_CLAIMS</ChoiceValue>
                    </ChoiceValues>
                    <DefaultValues>
                        <Value>POLICY_CONDITION</Value>
                    </DefaultValues>
                </AttributeSchema>
                <SubSchema name="scriptContext" inheritance="multiple" resourceName="contexts">
                    <AttributeSchema name="i18nKey" type="single"/>
                    <AttributeSchema name="languages" type="multiple_choice" syntax="string" i18nKey="st101">
                        <ChoiceValues>
                            <ChoiceValue i18nKey="language-01">JAVASCRIPT</ChoiceValue>
                            <ChoiceValue i18nKey="language-02">GROOVY</ChoiceValue>
                        </ChoiceValues>
                        <DefaultValues>
                            <Value>JAVASCRIPT</Value>
                            <Value>GROOVY</Value>
                        </DefaultValues>
                    </AttributeSchema>
                    <AttributeSchema name="defaultScript" type="single_choice" uitype="globalScriptSelect"
                                     propertiesViewBeanURL="../XUI/%23realms/{0}/scripts/edit/{1}" syntax="string"
                                     i18nKey="st103">
                        <ChoiceValues>
                            <ChoiceValuesClassName
                                    className="org.forgerock.openam.scripting.service.ScriptChoiceValues">
                                <AttributeValuePair>
                                    <Attribute name="GlobalOnly"/>
                                    <Value>true</Value>
                                </AttributeValuePair>
                            </ChoiceValuesClassName>
                        </ChoiceValues>
                    </AttributeSchema>
                    <SubSchema name="engineConfiguration" i18nKey="ec100">
                        <AttributeSchema name="i18nKey" type="single">
                            <DefaultValues>
                                <Value>engine-configuration</Value>
                            </DefaultValues>
                        </AttributeSchema>
                        <AttributeSchema name="serverTimeout"
                                         type="single" syntax="number_range" rangeStart="0"
                                         rangeEnd="2147483647" i18nKey="ec101">
                            <DefaultValues>
                                <Value>0</Value>
                            </DefaultValues>
                        </AttributeSchema>
                        <AttributeSchema name="coreThreads"
                                         type="single" syntax="number_range" rangeStart="1"
                                         rangeEnd="2147483647" i18nKey="ec102">
                            <DefaultValues>
                                <Value>10</Value>
                            </DefaultValues>
                        </AttributeSchema>
                        <AttributeSchema name="maxThreads"
                                         type="single" syntax="number_range" rangeStart="1"
                                         rangeEnd="2147483647" i18nKey="ec103">
                            <DefaultValues>
                                <Value>50</Value>
                            </DefaultValues>
                        </AttributeSchema>
                        <AttributeSchema name="queueSize"
                                         type="single" syntax="number_range" rangeStart="-1"
                                         rangeEnd="2147483647" i18nKey="ec104">
                            <DefaultValues>
                                <Value>10</Value>
                            </DefaultValues>
                        </AttributeSchema>
                        <AttributeSchema name="idleTimeout"
                                         type="single" syntax="number_range" rangeStart="0"
                                         rangeEnd="2147483647" i18nKey="ec105">
                            <DefaultValues>
                                <Value>60</Value>
                            </DefaultValues>
                        </AttributeSchema>
                        <AttributeSchema name="whiteList"
                                         type="list" syntax="string" i18nKey="ec106">
                            <DefaultValues>
                                <Value>java.lang.Boolean</Value>
                                <Value>java.lang.Byte</Value>
                                <Value>java.lang.Character</Value>
                                <Value>java.lang.Character$Subset</Value>
                                <Value>java.lang.Character$UnicodeBlock</Value>
                                <Value>java.lang.Double</Value>
                                <Value>java.lang.Float</Value>
                                <Value>java.lang.Integer</Value>
                                <Value>java.lang.Long</Value>
                                <Value>java.lang.Math</Value>
                                <Value>java.lang.Number</Value>
                                <Value>java.lang.Object</Value>
                                <Value>java.lang.Short</Value>
                                <Value>java.lang.StrictMath</Value>
                                <Value>java.lang.String</Value>
                                <Value>java.lang.Void</Value>
                                <Value>java.util.ArrayList</Value>
                                <Value>java.util.HashSet</Value>
                                <Value>java.util.HashMap</Value>
                                <Value>java.util.HashMap$KeyIterator</Value>
                                <Value>java.util.LinkedHashMap</Value>
                                <Value>java.util.LinkedHashSet</Value>
                                <Value>java.util.LinkedList</Value>
                                <Value>java.util.TreeMap</Value>
                                <Value>java.util.TreeSet</Value>
                                <Value>com.sun.identity.shared.debug.Debug</Value>
                                <Value>org.forgerock.http.client.*</Value>
                                <Value>org.forgerock.http.Client</Value>
                                <Value>org.forgerock.http.Handler</Value>
                                <Value>org.forgerock.http.Context</Value>
                                <Value>org.forgerock.http.context.RootContext</Value>
                                <Value>org.forgerock.http.protocol.Request</Value>
                                <Value>org.forgerock.http.protocol.Response</Value>
                                <Value>org.forgerock.util.promise.NeverThrowsException</Value>
                                <Value>org.forgerock.util.promise.Promise</Value>
                                <Value>org.forgerock.openam.scripting.api.http.GroovyHttpClient</Value>
                                <Value>org.forgerock.openam.scripting.api.http.JavaScriptHttpClient</Value>
                                <Value>org.forgerock.openam.scripting.api.ScriptedIdentity</Value>
                                <Value>org.forgerock.openam.scripting.api.ScriptedSession</Value>
                                <Value>groovy.json.JsonSlurper</Value>
                            </DefaultValues>
                        </AttributeSchema>
                        <AttributeSchema name="blackList"
                                         type="list" syntax="string" i18nKey="ec107">
                            <DefaultValues>
                                <Value>java.security.AccessController</Value>
                                <Value>java.lang.Class</Value>
                                <Value>java.lang.reflect.*</Value>
                            </DefaultValues>
                        </AttributeSchema>
                        <AttributeSchema name="useSecurityManager"
                                         type="single" syntax="boolean" i18nKey="ec108">
                            <BooleanValues>
                                <BooleanTrueValue i18nKey="i18nTrue">true</BooleanTrueValue>
                                <BooleanFalseValue i18nKey="i18nFalse">false</BooleanFalseValue>
                            </BooleanValues>
                            <DefaultValues>
                                <Value>true</Value>
                            </DefaultValues>
                        </AttributeSchema>
                    </SubSchema>
                </SubSchema>
                <SubSchema name="globalScripts" hideConfigUI="yes">
                    <SubSchema name="globalScript" inheritance="multiple">
                        <AttributeSchema name="name" type="single" syntax="string"/>
                        <AttributeSchema name="description" type="single" syntax="string"/>
                        <AttributeSchema name="context" type="single" syntax="string"/>
                        <AttributeSchema name="language" type="single">
                            <DefaultValues>
                                <Value>JAVASCRIPT</Value>
                            </DefaultValues>
                        </AttributeSchema>
                        <AttributeSchema name="script" type="single" syntax="script"/>
                        <AttributeSchema name="createdBy" type="single" syntax="string">
                            <DefaultValues>
                                <Value>id=dsameuser,ou=user,dc=openam,dc=forgerock,dc=org</Value>
                            </DefaultValues>
                        </AttributeSchema>
                        <AttributeSchema name="creationDate" type="single" syntax="string">
                            <DefaultValues>
                                <Value>1433147666269</Value>
                            </DefaultValues>
                        </AttributeSchema>
                        <AttributeSchema name="lastModifiedBy" type="single" syntax="string">
                            <DefaultValues>
                                <Value>id=dsameuser,ou=user,dc=openam,dc=forgerock,dc=org</Value>
                            </DefaultValues>
                        </AttributeSchema>
                        <AttributeSchema name="lastModifiedDate" type="single" syntax="string">
                            <DefaultValues>
                                <Value>1433147666269</Value>
                            </DefaultValues>
                        </AttributeSchema>
                    </SubSchema>
                </SubSchema>
            </Global>
            <Organization>
                <SubSchema name="scriptConfigurations">
                    <SubSchema name="scriptConfiguration" inheritance="multiple" resourceName="scripts">
                        <AttributeSchema name="name" type="single" syntax="string" i18nKey="no-i18n"/>
                        <AttributeSchema name="description" type="single" syntax="string" i18nKey="no-i18n"/>
                        <AttributeSchema name="script" type="single" syntax="script" i18nKey="no-i18n"/>
                        <AttributeSchema name="language" type="single" syntax="string" i18nKey="no-i18n">
                            <ChoiceValues>
                                <ChoiceValue i18nKey="language-01">JAVASCRIPT</ChoiceValue>
                                <ChoiceValue i18nKey="language-02">GROOVY</ChoiceValue>
                            </ChoiceValues>
                        </AttributeSchema>
                        <AttributeSchema name="context" type="single" syntax="string" i18nKey="no-i18n">
                            <ChoiceValues>
                                <ChoiceValue i18nKey="script-type-01">POLICY_CONDITION</ChoiceValue>
                                <ChoiceValue i18nKey="script-type-02">AUTHENTICATION_SERVER_SIDE</ChoiceValue>
                                <ChoiceValue i18nKey="script-type-03">AUTHENTICATION_CLIENT_SIDE</ChoiceValue>
                                <ChoiceValue i18nKey="script-type-04">OIDC_CLAIMS</ChoiceValue>
                            </ChoiceValues>
                        </AttributeSchema>
                        <AttributeSchema name="createdBy" type="single" syntax="string" i18nKey="no-i18n"/>
                        <AttributeSchema name="creationDate" type="single" syntax="string" i18nKey="no-i18n"/>
                        <AttributeSchema name="lastModifiedBy" type="single" syntax="string" i18nKey="no-i18n"/>
                        <AttributeSchema name="lastModifiedDate" type="single" syntax="string" i18nKey="no-i18n"/>
                    </SubSchema>
                </SubSchema>
            </Organization>
        </Schema>

        <Configuration>
            <GlobalConfiguration>
                <SubConfiguration name="POLICY_CONDITION" id="scriptContext">
                    <AttributeValuePair>
                        <Attribute name="i18nKey"/>
                        <Value>script-type-01</Value>
                    </AttributeValuePair>
                    <AttributeValuePair>
                        <Attribute name="defaultScript"/>
                        <Value>9de3eb62-f131-4fac-a294-7bd170fd4acb</Value>
                    </AttributeValuePair>
                    <SubConfiguration name="engineConfiguration" id="engineConfiguration"/>
                </SubConfiguration>
                <SubConfiguration name="AUTHENTICATION_SERVER_SIDE" id="scriptContext">
                    <AttributeValuePair>
                        <Attribute name="i18nKey"/>
                        <Value>script-type-02</Value>
                    </AttributeValuePair>
                    <AttributeValuePair>
                        <Attribute name="defaultScript"/>
                        <Value>7e3d7067-d50f-4674-8c76-a3e13a810c33</Value>
                    </AttributeValuePair>
                    <SubConfiguration name="engineConfiguration" id="engineConfiguration">
                        <AttributeValuePair>
                            <Attribute name="whiteList"/>
                            <Value>java.lang.Boolean</Value>
                            <Value>java.lang.Byte</Value>
                            <Value>java.lang.Character</Value>
                            <Value>java.lang.Character$Subset</Value>
                            <Value>java.lang.Character$UnicodeBlock</Value>
                            <Value>java.lang.Double</Value>
                            <Value>java.lang.Float</Value>
                            <Value>java.lang.Integer</Value>
                            <Value>java.lang.Long</Value>
                            <Value>java.lang.Math</Value>
                            <Value>java.lang.Number</Value>
                            <Value>java.lang.Object</Value>
                            <Value>java.lang.Short</Value>
                            <Value>java.lang.StrictMath</Value>
                            <Value>java.lang.String</Value>
                            <Value>java.lang.Void</Value>
                            <Value>java.util.ArrayList</Value>
                            <Value>java.util.HashSet</Value>
                            <Value>java.util.HashMap</Value>
                            <Value>java.util.HashMap$KeyIterator</Value>
                            <Value>java.util.LinkedHashMap</Value>
                            <Value>java.util.LinkedHashSet</Value>
                            <Value>java.util.LinkedList</Value>
                            <Value>java.util.TreeMap</Value>
                            <Value>java.util.TreeSet</Value>
                            <Value>com.sun.identity.shared.debug.Debug</Value>
                            <Value>org.forgerock.openam.authentication.modules.scripted.*</Value>
                            <Value>org.forgerock.openam.scripting.api.http.GroovyHttpClient</Value>
                            <Value>org.forgerock.openam.scripting.api.http.JavaScriptHttpClient</Value>
                            <Value>org.forgerock.openam.scripting.api.ScriptedIdentity</Value>
                            <Value>org.forgerock.openam.scripting.api.ScriptedSession</Value>
                            <Value>org.forgerock.http.client.*</Value>
                            <Value>groovy.json.JsonSlurper</Value>
                        </AttributeValuePair>
                    </SubConfiguration>
                </SubConfiguration>
                <SubConfiguration name="AUTHENTICATION_CLIENT_SIDE" id="scriptContext">
                    <AttributeValuePair>
                        <Attribute name="i18nKey"/>
                        <Value>script-type-03</Value>
                    </AttributeValuePair>
                    <AttributeValuePair>
                        <Attribute name="languages"/>
                        <Value>JAVASCRIPT</Value>
                    </AttributeValuePair>
                    <AttributeValuePair>
                        <Attribute name="defaultScript"/>
                        <Value>[Empty]</Value>
                    </AttributeValuePair>
                </SubConfiguration>
                <SubConfiguration name="OIDC_CLAIMS" id="scriptContext">
                    <AttributeValuePair>
                        <Attribute name="i18nKey"/>
                        <Value>script-type-04</Value>
                    </AttributeValuePair>
                    <AttributeValuePair>
                        <Attribute name="defaultScript"/>
                        <Value>36863ffb-40ec-48b9-94b1-9a99f71cc3b5</Value>
                    </AttributeValuePair>
                    <SubConfiguration name="engineConfiguration" id="engineConfiguration">
                        <AttributeValuePair>
                            <Attribute name="whiteList"/>
                            <Value>java.lang.Boolean</Value>
                            <Value>java.lang.Byte</Value>
                            <Value>java.lang.Character</Value>
                            <Value>java.lang.Character$Subset</Value>
                            <Value>java.lang.Character$UnicodeBlock</Value>
                            <Value>java.lang.Double</Value>
                            <Value>java.lang.Float</Value>
                            <Value>java.lang.Integer</Value>
                            <Value>java.lang.Long</Value>
                            <Value>java.lang.Math</Value>
                            <Value>java.lang.Number</Value>
                            <Value>java.lang.Object</Value>
                            <Value>java.lang.Short</Value>
                            <Value>java.lang.StrictMath</Value>
                            <Value>java.lang.String</Value>
                            <Value>java.lang.Void</Value>
                            <Value>java.util.ArrayList</Value>
                            <Value>java.util.HashSet</Value>
                            <Value>java.util.HashMap</Value>
                            <Value>java.util.HashMap$Entry</Value>
                            <Value>java.util.HashMap$KeyIterator</Value>
                            <Value>java.util.LinkedHashMap</Value>
                            <Value>java.util.LinkedHashSet</Value>
                            <Value>java.util.LinkedList</Value>
                            <Value>java.util.TreeMap</Value>
                            <Value>java.util.TreeSet</Value>
                            <Value>com.sun.identity.shared.debug.Debug</Value>
                            <Value>com.iplanet.sso.providers.dpro.SSOTokenImpl</Value>
                            <Value>org.forgerock.http.client.*</Value>
                            <Value>groovy.json.JsonSlurper</Value>
                            <Value>com.sun.identity.idm.AMIdentity</Value>
                            <Value>java.util.LinkedHashMap$Entry</Value>
                            <Value>java.util.LinkedHashMap$LinkedEntrySet</Value>
                            <Value>org.forgerock.openam.oauth2.OpenAMAccessToken</Value>
                            <Value>java.util.HashMap$Node</Value>
                            <Value>org.forgerock.oauth2.core.UserInfoClaims</Value>
                            <Value>org.codehaus.groovy.runtime.GStringImpl</Value>
                            <Value>org.forgerock.openam.sso.providers.stateless.StatelessSSOToken</Value>
                        </AttributeValuePair>
                    </SubConfiguration>
                </SubConfiguration>
                <SubConfiguration name="globalScripts" id="globalScripts">
                    <SubConfiguration name="9de3eb62-f131-4fac-a294-7bd170fd4acb" id="globalScript">
                        <AttributeValuePair>
                            <Attribute name="name"/>
                            <Value>Scripted Policy Condition</Value>
                        </AttributeValuePair>
                        <AttributeValuePair>
                            <Attribute name="description"/>
                            <Value>Default global script for Scripted Policy Conditions</Value>
                        </AttributeValuePair>
                        <AttributeValuePair>
                            <Attribute name="context"/>
                            <Value>POLICY_CONDITION</Value>
                        </AttributeValuePair>
                        <AttributeValuePair>
                            <Attribute name="script"/>
                            <Value>
/**
 * This is a Policy Condition example script. It demonstrates how to access a user&apos;s information,
 * use that information in external HTTP calls and make a policy decision based on the outcome.
 */

var userAddress, userIP, resourceHost;

if (validateAndInitializeParameters()) {

    var countryFromUserAddress = getCountryFromUserAddress();
    logger.message(&quot;Country retrieved from user&apos;s address: &quot; + countryFromUserAddress);
    var countryFromUserIP = getCountryFromUserIP();
    logger.message(&quot;Country retrieved from user&apos;s IP: &quot; + countryFromUserIP);
    var countryFromResourceURI = getCountryFromResourceURI();
    logger.message(&quot;Country retrieved from resource URI: &quot; + countryFromResourceURI);

    if (countryFromUserAddress === countryFromUserIP &amp;&amp; countryFromUserAddress === countryFromResourceURI) {
        logger.message(&quot;Authorization Succeeded&quot;);
        responseAttributes.put(&quot;countryOfOrigin&quot;, [countryFromUserAddress]);
        authorized = true;
    } else {
        logger.message(&quot;Authorization Failed&quot;);
        authorized = false;
    }

} else {
    logger.message(&quot;Required parameters not found. Authorization Failed.&quot;);
    authorized = false;
}

/**
 * Use the user&apos;s address to lookup their country of residence.
 *
 * @returns {*} The user&apos;s country of residence.
 */
function getCountryFromUserAddress() {
    var response = httpClient.get(&quot;http://maps.googleapis.com/maps/api/geocode/json?address=&quot; +
        encodeURIComponent(userAddress), {
        cookies: [],
        headers: []
    });
    logResponse(response);

    var geocode = JSON.parse(response.getEntity());
    var i;
    for (i = 0; i &lt; geocode.results.length; i++) {
        var result = geocode.results[i];
        var j;
        for (j = 0; j &lt; result.address_components.length; i++) {
            if (result.address_components[i].types[0] == &quot;country&quot;) {
                return result.address_components[i].long_name;
            }
        }
    }
}

/**
 * Use the user&apos;s IP to lookup the country from which the request originated.
 *
 * @returns {*} The country from which the request originated.
 */
function getCountryFromUserIP() {
    var response = httpClient.get(&quot;http://ip-api.com/json/&quot; + userIP, {
        cookies: [],
        headers: []
    });
    logResponse(response);

    var result = JSON.parse(response.getEntity());
    if (result) {
        return result.country;
    }
}

/**
 * Use the requested resource&apos;s host name to lookup the country where the resource is hosted.
 *
 * @returns {*} The country in which the resource is hosted.
 */
function getCountryFromResourceURI() {
    response = httpClient.get(&quot;http://ip-api.com/json/&quot; + encodeURIComponent(resourceHost), {
        cookies: [],
        headers: []
    });
    logResponse(response);

    var result = JSON.parse(response.getEntity());
    if (result) {
        return result.country;
    }
}

/**
 * Retrieve and validate the variables required to make the external HTTP calls.
 *
 * @returns {boolean} Will be true if validation was successful.
 */
function validateAndInitializeParameters() {
    var userAddressSet = identity.getAttribute(&quot;postalAddress&quot;);
    if (userAddressSet == null || userAddressSet.isEmpty()) {
        logger.warning(&quot;No address specified for user: &quot; + username);
        return false;
    }
    userAddress = userAddressSet.iterator().next();
    logger.message(&quot;User address: &quot; + userAddress);

    if (!environment) {
        logger.warning(&quot;No environment parameters specified in the evaluation request.&quot;);
        return false;
    }

    var ipSet = environment.get(&quot;IP&quot;);
    if (ipSet == null || ipSet.isEmpty()) {
        logger.warning(&quot;No IP specified in the evaluation request environment parameters.&quot;);
        return false;
    }
    userIP = ipSet.iterator().next();
    logger.message(&quot;User IP: &quot; + userIP);

    if (!resourceURI) {
        logger.warning(&quot;No resource URI specified.&quot;);
        return false;
    }
    resourceHost = resourceURI.match(/^(.*:\/\/)(www\.)?([A-Za-z0-9\-\.]+)(:[0-9]+)?(.*)$/)[3];
    logger.message(&quot;Resource host: &quot; + resourceHost);

    return true;
}

function logResponse(response) {
    logger.message(&quot;User REST Call. Status: &quot; + response.getStatusCode() + &quot;, Body: &quot; + response.getEntity());
}
                            </Value>
                        </AttributeValuePair>
                    </SubConfiguration>
                    <SubConfiguration name="7e3d7067-d50f-4674-8c76-a3e13a810c33" id="globalScript">
                        <AttributeValuePair>
                            <Attribute name="name"/>
                            <Value>Scripted Module - Server Side</Value>
                        </AttributeValuePair>
                        <AttributeValuePair>
                            <Attribute name="description"/>
                            <Value>Default global script for server side Scripted Authentication Module</Value>
                        </AttributeValuePair>
                        <AttributeValuePair>
                            <Attribute name="context"/>
                            <Value>AUTHENTICATION_SERVER_SIDE</Value>
                        </AttributeValuePair>
                        <AttributeValuePair>
                            <Attribute name="script"/>
                            <Value>

var START_TIME = 9;  // 9am
var END_TIME   = 17; // 5pm

logger.message(&quot;Starting authentication javascript&quot;);
logger.message(&quot;User: &quot; + username);

// Log out current cookies in the request
if (logger.messageEnabled()) {
    var cookies = requestData.getHeaders(&apos;Cookie&apos;);
    for (cookie in cookies) {
        logger.message(&apos;Cookie: &apos; + cookies[cookie]);
    }
}

if (username) {
    // Fetch user information via REST
    var response = httpClient.get(&quot;http://localhost:8080/openam/json/users/&quot; + username, {
        cookies : [],
        headers : []
    });
    // Log out response from REST call
    logger.message(&quot;User REST Call. Status: &quot; + response.getStatusCode() + &quot;, Body: &quot; + response.getEntity());
}

var now = new Date();
logger.message(&quot;Current time: &quot; + now.getHours());
if (now.getHours() &amp;lt; START_TIME || now.getHours() &amp;gt; END_TIME) {
    logger.error(&quot;Login forbidden outside work hours!&quot;);
    authState = FAILED;
} else {
    logger.message(&quot;Authentication allowed!&quot;);
    authState = SUCCESS;
}
                            </Value>
                        </AttributeValuePair>
                    </SubConfiguration>
                    <SubConfiguration name="c827d2b4-3608-4693-868e-bbcf86bd87c7" id="globalScript">
                        <AttributeValuePair>
                            <Attribute name="name"/>
                            <Value>Scripted Module - Client Side</Value>
                        </AttributeValuePair>
                        <AttributeValuePair>
                            <Attribute name="description"/>
                            <Value>Default global script for client side Scripted Authentication Module</Value>
                        </AttributeValuePair>
                        <AttributeValuePair>
                            <Attribute name="context"/>
                            <Value>AUTHENTICATION_CLIENT_SIDE</Value>
                        </AttributeValuePair>
                        <AttributeValuePair>
                            <Attribute name="script"/>
                            <Value>
/* Default Authentication client side script to use as a template for new scripts */
                            </Value>
                        </AttributeValuePair>
                    </SubConfiguration>
                    <SubConfiguration name="703dab1a-1921-4981-98dd-b8e5349d8548" id="globalScript">
                        <AttributeValuePair>
                            <Attribute name="name"/>
                            <Value>Device Id (Match) - Server Side</Value>
                        </AttributeValuePair>
                        <AttributeValuePair>
                            <Attribute name="description"/>
                            <Value>Default global script for server side Device Id (Match) Authentication Module</Value>
                        </AttributeValuePair>
                        <AttributeValuePair>
                            <Attribute name="context"/>
                            <Value>AUTHENTICATION_SERVER_SIDE</Value>
                        </AttributeValuePair>
                        <AttributeValuePair>
                            <Attribute name="script"/>
                            <Value>
/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 *
 * Copyright (c) 2009 Sun Microsystems Inc. All Rights Reserved
 *
 * The contents of this file are subject to the terms
 * of the Common Development and Distribution License
 * (the License). You may not use this file except in
 * compliance with the License.
 *
 * You can obtain a copy of the License at
 * https://opensso.dev.java.net/public/CDDLv1.0.html or
 * opensso/legal/CDDLv1.0.txt
 * See the License for the specific language governing
 * permission and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL
 * Header Notice in each file and include the License file
 * at opensso/legal/CDDLv1.0.txt.
 * If applicable, add the following below the CDDL Header,
 * with the fields enclosed by brackets [] replaced by
 * your own identifying information:
 * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
 *
 */
/*
 * Portions Copyrighted 2013 Syntegrity.
 * Portions Copyrighted 2013-2015 ForgeRock AS.
 */

var ScalarComparator = {}, ScreenComparator = {}, MultiValueComparator = {}, UserAgentComparator = {}, GeolocationComparator = {};

var config = {
    profileExpiration: 30,              //in days
    maxProfilesAllowed: 5,
    maxPenaltyPoints: 0,
    attributes: {
        screen: {
            required: true,
            comparator: ScreenComparator,
            args: {
                penaltyPoints: 50
            }
        },
        plugins: {
            installedPlugins: {
                required: false,
                comparator: MultiValueComparator,
                args: {
                    maxPercentageDifference: 10,
                    maxDifferences: 5,
                    penaltyPoints: 100
                }
            }
        },
        fonts: {
            installedFonts: {
                required: false,
                comparator: MultiValueComparator,
                args: {
                    maxPercentageDifference: 10,
                    maxDifferences: 5,
                    penaltyPoints: 100
                }
            }
        },
        timezone: {
            timezone: {
                required: false,
                comparator: ScalarComparator,
                args: {
                    penaltyPoints: 100
                }
            }
        },
        userAgent: {
            required: true,
            comparator: UserAgentComparator,
            args: {
                ignoreVersion: true,
                penaltyPoints: 100
            }
        },
        geolocation: {
            required: false,
            comparator: GeolocationComparator,
            args: {
                allowedRange: 100,			//in miles
                penaltyPoints: 100
            }
        }
    }
};

//---------------------------------------------------------------------------//
//                           Comparator functions                            //
//---------------------------------------------------------------------------//

var all, any, calculateDistance, calculateIntersection, calculatePercentage, nullOrUndefined, splitAndTrim,
    undefinedLocation;

// ComparisonResult

/**
 * Constructs an instance of a ComparisonResult with the given penalty points.
 *
 * @param penaltyPoints (Number) The penalty points for the comparison (defaults to 0).
 * @param additionalInfoInCurrentValue (boolean) Whether the current value contains more information
 *                                               than the stored value (defaults to false).
 */
function ComparisonResult() {

    var penaltyPoints = 0,
        additionalInfoInCurrentValue = false;

    if (arguments[0] !== undefined &amp;&amp; arguments[1] !== undefined) {
        penaltyPoints = arguments[0];
        additionalInfoInCurrentValue = arguments[1];
    }

    if (arguments[0] !== undefined &amp;&amp; arguments[1] === undefined) {
        if (typeof(arguments[0]) === &quot;boolean&quot;) {
            additionalInfoInCurrentValue = arguments[0];
        } else {
            penaltyPoints = arguments[0];
        }
    }

    this.penaltyPoints = penaltyPoints;
    this.additionalInfoInCurrentValue = additionalInfoInCurrentValue;

}

ComparisonResult.ZERO_PENALTY_POINTS = new ComparisonResult(0);

/**
 * Static method for functional programming.
 *
 * @return boolean true if comparisonResult.isSuccessful().
 */
ComparisonResult.isSuccessful =  function(comparisonResult) {
    return comparisonResult.isSuccessful();
};


/**
 * Static method for functional programming.
 *
 * @return boolean true if comparisonResult.additionalInfoInCurrentValue.
 */
ComparisonResult.additionalInfoInCurrentValue =  function(comparisonResult) {
    return comparisonResult.additionalInfoInCurrentValue;
};

/**
 * Comparison function that can be provided as an argument to array.sort
 */
ComparisonResult.compare = function(first, second) {
    if (nullOrUndefined(first) &amp;&amp; nullOrUndefined(second)) {
        return 0;
    } else if (nullOrUndefined(first)) {
        return -1;
    } else if (nullOrUndefined(second)) {
        return 1;
    } else {
        if (first.penaltyPoints !== second.penaltyPoints) {
            return first.penaltyPoints - second.penaltyPoints;
        } else {
            return (first.additionalInfoInCurrentValue ? 1 : 0) - (second.additionalInfoInCurrentValue ? 1 : 0);
        }
    }
};

/**
 * Amalgamates the given ComparisonResult into this ComparisonResult.
 *
 * @param comparisonResult The ComparisonResult to include.
 */
ComparisonResult.prototype.addComparisonResult = function(comparisonResult) {
    this.penaltyPoints += comparisonResult.penaltyPoints;
    if (comparisonResult.additionalInfoInCurrentValue) {
        this.additionalInfoInCurrentValue = comparisonResult.additionalInfoInCurrentValue;
    }
};

/**
 * Returns true if no penalty points have been assigned for the comparison.
 *
 * @return boolean true if the comparison was successful.
 */
ComparisonResult.prototype.isSuccessful = function() {
    return nullOrUndefined(this.penaltyPoints) || this.penaltyPoints === 0;
};

/**
 * Compares two simple objects (String|Number) and if they are equal then returns a ComparisonResult with zero
 * penalty points assigned, otherwise returns a ComparisonResult with the given number of penalty points assigned.
 *
 * @param currentValue (String|Number) The current value.
 * @param storedValue (String|Number) The stored value.
 * @param config: {
 *            &quot;penaltyPoints&quot;: (Number) The number of penalty points.
 *        }
 * @return ComparisonResult.
 */
ScalarComparator.compare = function (currentValue, storedValue, config) {
    if (logger.messageEnabled()) {
        logger.message(&quot;StringComparator.compare:currentValue: &quot; + JSON.stringify(currentValue));
        logger.message(&quot;StringComparator.compare:storedValue: &quot; + JSON.stringify(storedValue));
        logger.message(&quot;StringComparator.compare:config: &quot; + JSON.stringify(config));
    }
    if (config.penaltyPoints === 0) {
        return ComparisonResult.ZERO_PENALTY_POINTS;
    }

    if (!nullOrUndefined(storedValue)) {
        if (nullOrUndefined(currentValue) || currentValue !== storedValue) {
            return new ComparisonResult(config.penaltyPoints);
        }
    } else if (!nullOrUndefined(currentValue)) {
        return new ComparisonResult(true);
    }

    return ComparisonResult.ZERO_PENALTY_POINTS;
};

/**
 * Compares two screens and if they are equal then returns a ComparisonResult with zero penalty points assigned,
 * otherwise returns a ComparisonResult with the given number of penalty points assigned.
 *
 * @param currentValue: {
 *            &quot;screenWidth&quot;: (Number) The current client screen width.
 *            &quot;screenHeight&quot;: (Number) The current client screen height.
 *            &quot;screenColourDepth&quot;: (Number) The current client screen colour depth.
 *        }
 * @param storedValue: {
 *            &quot;screenWidth&quot;: (Number) The stored client screen width.
 *            &quot;screenHeight&quot;: (Number) The stored client screen height.
 *            &quot;screenColourDepth&quot;: (Number) The stored client screen colour depth.
 *        }
 * @param config: {
 *            &quot;penaltyPoints&quot;: (Number) The number of penalty points.
 *        }
 * @return ComparisonResult
 */
ScreenComparator.compare = function (currentValue, storedValue, config) {
    if (logger.messageEnabled()) {
        logger.message(&quot;ScreenComparator.compare:currentValue: &quot; + JSON.stringify(currentValue));
        logger.message(&quot;ScreenComparator.compare:storedValue: &quot; + JSON.stringify(storedValue));
        logger.message(&quot;ScreenComparator.compare:config: &quot; + JSON.stringify(config));
    }

    if (nullOrUndefined(currentValue)) {
        currentValue = {screenWidth: null, screenHeight: null, screenColourDepth: null};
    }
    if (nullOrUndefined(storedValue)) {
        storedValue = {screenWidth: null, screenHeight: null, screenColourDepth: null};
    }

    var comparisonResults = [
        ScalarComparator.compare(currentValue.screenWidth, storedValue.screenWidth, config),
        ScalarComparator.compare(currentValue.screenHeight, storedValue.screenHeight, config),
        ScalarComparator.compare(currentValue.screenColourDepth, storedValue.screenColourDepth, config)];

    if (all(comparisonResults, ComparisonResult.isSuccessful)) {
        return new ComparisonResult(any(comparisonResults, ComparisonResult.additionalInfoInCurrentValue));
    } else {
        return new ComparisonResult(config.penaltyPoints);
    }
};

/**
 * Splits both values using delimiter, trims every value and compares collections of values.
 * Returns zero-result for same multi-value attributes.
 *
 * If collections are not same checks if number of differences is less or equal maxDifferences or
 * percentage of difference is less or equal maxPercentageDifference.
 *
 * If yes then returns zero-result with additional info, else returns penaltyPoints-result.
 *
 * @param currentValue: (String) The current value.
 * @param storedValue: (String) The stored value.
 * @param config: {
 *            &quot;maxPercentageDifference&quot;: (Number) The max difference percentage in the values,
 *                                                before the penalty is assigned.
 *            &quot;maxDifferences&quot;: (Number) The max number of differences in the values,
 *                                       before the penalty points are assigned.
 *            &quot;penaltyPoints&quot;: (Number) The number of penalty points.
  *        }
 * @return ComparisonResult
 */
MultiValueComparator.compare = function (currentValue, storedValue, config) {
    if (logger.messageEnabled()) {
        logger.message(&quot;MultiValueComparator.compare:currentValue: &quot; + JSON.stringify(currentValue));
        logger.message(&quot;MultiValueComparator.compare:storedValue: &quot; + JSON.stringify(storedValue));
        logger.message(&quot;MultiValueComparator.compare:config: &quot; + JSON.stringify(config));
    }

    var delimiter = &quot;;&quot;,
        currentValues = splitAndTrim(currentValue, delimiter),
        storedValues = splitAndTrim(storedValue, delimiter),
        maxNumberOfElements = Math.max(currentValues.length, storedValues.length),
        numberOfTheSameElements = calculateIntersection(currentValues, storedValues).length,
        numberOfDifferences = maxNumberOfElements - numberOfTheSameElements,
        percentageOfDifferences = calculatePercentage(numberOfDifferences, maxNumberOfElements);

    if (nullOrUndefined(storedValue) &amp;&amp; !nullOrUndefined(currentValue)) {
        return new ComparisonResult(true);
    }

    if (logger.messageEnabled()) {
        logger.message(numberOfTheSameElements + &quot; of &quot; + maxNumberOfElements + &quot; are same&quot;);
    }

    if (maxNumberOfElements === 0) {
        logger.message(&quot;Ignored because no attributes found in both profiles&quot;);
        return ComparisonResult.ZERO_PENALTY_POINTS;
    }

    if (numberOfTheSameElements === maxNumberOfElements) {
        logger.message(&quot;Ignored because all attributes are same&quot;);
        return ComparisonResult.ZERO_PENALTY_POINTS;
    }

    if (numberOfDifferences &gt; config.maxDifferences) {
        if (logger.messageEnabled()) {
            logger.message(&quot;Would be ignored if not more than &quot; + config.maxDifferences + &quot; differences&quot;);
        }
        return new ComparisonResult(config.penaltyPoints);
    }

    if (percentageOfDifferences &gt; config.maxPercentageDifference) {
        if (logger.messageEnabled()) {
            logger.message(percentageOfDifferences + &quot; percents are different&quot;);
            logger.message(&quot;Would be ignored if not more than &quot; + config.maxPercentageDifference + &quot; percent&quot;);
        }
        return new ComparisonResult(config.penaltyPoints);
    }

    if (logger.messageEnabled()) {
        logger.message(&quot;Ignored because number of differences(&quot; + numberOfDifferences + &quot;) not more than &quot;
            + config.maxDifferences);
        logger.message(percentageOfDifferences + &quot; percents are different&quot;);
        logger.message(&quot;Ignored because not more than &quot; + config.maxPercentageDifference + &quot; percent&quot;);
    }
    return new ComparisonResult(true);
};

/**
 * Compares two User Agent Strings and if they are equal then returns a ComparisonResult with zero penalty
 * points assigned, otherwise returns a ComparisonResult with the given number of penalty points assigned.
 *
 * @param currentValue (String) The current value.
 * @param storedValue (String) The stored value.
 * @param config: {
 *            &quot;ignoreVersion&quot;: (boolean) If the version numbers in the User Agent Strings should be ignore
 *                                       in the comparison.
 *            &quot;penaltyPoints&quot;: (Number) The number of penalty points.
 *        }
 * @return A ComparisonResult.
 */
UserAgentComparator.compare = function (currentValue, storedValue, config) {
    if (logger.messageEnabled()) {
        logger.message(&quot;UserAgentComparator.compare:currentValue: &quot; + JSON.stringify(currentValue));
        logger.message(&quot;UserAgentComparator.compare:storedValue: &quot; + JSON.stringify(storedValue));
        logger.message(&quot;UserAgentComparator.compare:config: &quot; + JSON.stringify(config));
    }

    if (config.ignoreVersion) {
        // remove version number
        currentValue = nullOrUndefined(currentValue) ? null : currentValue.replace(/[\d\.]+/g, &quot;&quot;).trim();
        storedValue = nullOrUndefined(storedValue) ? null : storedValue.replace(/[\d\.]+/g, &quot;&quot;).trim();
    }

    return ScalarComparator.compare(currentValue, storedValue, config);
};

/**
 * Compares two locations, taking into account a degree of difference.
 *
 * @param currentValue: {
 *            &quot;latitude&quot;: (Number) The current latitude.
 *            &quot;longitude&quot;: (Number) The current longitude.
 *        }
 * @param storedValue: {
 *            &quot;latitude&quot;: (Number) The stored latitude.
 *            &quot;longitude&quot;: (Number) The stored longitude.
 *        }
 * @param config: {
 *            &quot;allowedRange&quot;: (Number) The max difference allowed in the two locations, before the penalty is assigned.
 *            &quot;penaltyPoints&quot;: (Number) The number of penalty points.
*         }
 * @return ComparisonResult
 */
GeolocationComparator.compare = function (currentValue, storedValue, config) {
    if (logger.messageEnabled()) {
        logger.message(&quot;GeolocationComparator.compare:currentValue: &quot; + JSON.stringify(currentValue));
        logger.message(&quot;GeolocationComparator.compare:storedValue: &quot; + JSON.stringify(storedValue));
        logger.message(&quot;GeolocationComparator.compare:config: &quot; + JSON.stringify(config));
    }

    // Check for undefined stored or current locations

    if (undefinedLocation(currentValue) &amp;&amp; undefinedLocation(storedValue)) {
        return ComparisonResult.ZERO_PENALTY_POINTS;
    }
    if (undefinedLocation(currentValue) &amp;&amp; !undefinedLocation(storedValue)) {
        return new ComparisonResult(config.penaltyPoints);
    }
    if (!undefinedLocation(currentValue) &amp;&amp; undefinedLocation(storedValue)) {
        return new ComparisonResult(true);
    }

    // Both locations defined, therefore perform comparison

    var distance = calculateDistance(currentValue, storedValue);

    if (logger.messageEnabled()) {
        logger.message(&quot;Distance between (&quot; + currentValue.latitude + &quot;,&quot; + currentValue.longitude + &quot;) and (&quot; +
            storedValue.latitude + &quot;,&quot; + storedValue.longitude + &quot;) is &quot; + distance + &quot; miles&quot;);
    }

    if (parseFloat(distance.toPrecision(5)) === 0) {
        logger.message(&quot;Location is the same&quot;);
        return ComparisonResult.ZERO_PENALTY_POINTS;
    }

    if (distance &lt;= config.allowedRange) {
        if (logger.messageEnabled()) {
            logger.message(&quot;Tolerated because distance not more then &quot; + config.allowedRange);
        }
        return new ComparisonResult(true);
    } else {
        if (logger.messageEnabled()) {
            logger.message(&quot;Would be ignored if distance not more then &quot; + config.allowedRange);
        }
        return new ComparisonResult(config.penaltyPoints);
    }
};


//---------------------------------------------------------------------------//
//                    Device Print Logic - DO NOT MODIFY                     //
//---------------------------------------------------------------------------//

// Utility functions

/**
 * Returns true if evaluating function f on each element of the Array a returns true.
 *
 * @param a: (Array) The array of elements to evaluate
 * @param f: (Function) A single argument function for mapping elements of the array to boolean.
 * @return boolean.
 */
all = function(a, f) {
    var i;
    for (i = 0; i &lt; a.length; i++) {
        if (f(a[i]) === false) {
            return false;
        }
    }
    return true;
};

/**
 * Returns true if evaluating function f on any element of the Array a returns true.
 *
 * @param a: (Array) The array of elements to evaluate
 * @param f: (Function) A single argument function for mapping elements of the array to boolean.
 * @return boolean.
 */
any = function(a, f) {
    var i;
    for (i = 0; i &lt; a.length; i++) {
        if (f(a[i]) === true) {
            return true;
        }
    }
    return false;
};

/**
 * Returns true if the provided location is null or has undefined longitude or latitude values.
 *
 * @param location: {
 *            &quot;latitude&quot;: (Number) The latitude.
 *            &quot;longitude&quot;: (Number) The longitude.
 *        }
 * @return boolean
 */
undefinedLocation = function(location) {
    return nullOrUndefined(location) || nullOrUndefined(location.latitude) || nullOrUndefined(location.longitude);
};

/**
 * Returns true if the provided value is null or undefined.
 *
 * @param value: a value of any type
 * @return boolean
 */
nullOrUndefined = function(value) {
    return value === null || value === undefined;
};

/**
 * Calculates the distances between the two locations.
 *
 * @param first: {
 *            &quot;latitude&quot;: (Number) The first latitude.
 *            &quot;longitude&quot;: (Number) The first longitude.
 *        }
 * @param second: {
 *            &quot;latitude&quot;: (Number) The second latitude.
 *            &quot;longitude&quot;: (Number) The second longitude.
 *        }
 * @return Number The distance between the two locations.
 */
calculateDistance = function(first, second) {
    var factor = (Math.PI / 180),
        theta,
        dist;
    function degreesToRadians(degrees) {
        return degrees * factor;
    }
    function radiansToDegrees(radians) {
        return radians / factor;
    }
    theta = first.longitude - second.longitude;
    dist = Math.sin(degreesToRadians(first.latitude)) * Math.sin(degreesToRadians(second.latitude))
        + Math.cos(degreesToRadians(first.latitude)) * Math.cos(degreesToRadians(second.latitude))
        * Math.cos(degreesToRadians(theta));
    dist = Math.acos(dist);
    dist = radiansToDegrees(dist);
    dist = dist * 60 * 1.1515;
    return dist;
};

/**
 * Converts a String holding a delimited sequence of values into an array.
 *
 * @param text (String) The String representation of a delimited sequence of values.
 * @param delimiter (String) The character delimiting values within the text String.
 * @return (Array) The comma separated values.
 */
splitAndTrim = function(text, delimiter) {

    var results = [],
        i,
        values,
        value;
    if (text === null) {
        return results;
    }

    values = text.split(delimiter);
    for (i = 0; i &lt; values.length; i++) {
        value = values[i].trim();
        if (value !== &quot;&quot;) {
            results.push(value);
        }
    }

    return results;
};

/**
 * Converts value to a percentage of range.
 *
 * @param value (Number) The actual number to be converted to a percentage.
 * @param range (Number) The total number of values (i.e. represents 100%).
 * @return (Number) The percentage.
 */
calculatePercentage = function(value, range) {
    if (range === 0) {
        return 0;
    }
    return parseFloat((value / range).toPrecision(2)) * 100;
};

/**
 * Creates a new array containing only those elements found in both arrays received as arguments.
 *
 * @param first (Array) The first array.
 * @param second (Array) The second array.
 * @return (Array) The elements that found in first and second.
 */
calculateIntersection = function(first, second) {
    return first.filter(function(element) {
        return second.indexOf(element) !== -1;
    });
};

function getValue(obj, attributePath) {
    var value = obj,
        i;
    for (i = 0; i &lt; attributePath.length; i++) {
        if (value === undefined) {
            return null;
        }
        value = value[attributePath[i]];
    }
    return value;
}


function isLeafNode(attributeConfig) {
    return attributeConfig.comparator !== undefined;
}

function getAttributePaths(attributeConfig, attributePath) {

    var attributePaths = [],
        attributeName,
        attrPaths,
        attrPath,
        i;

    for (attributeName in attributeConfig) {
        if (attributeConfig.hasOwnProperty(attributeName)) {

            if (isLeafNode(attributeConfig[attributeName])) {
                attrPath = attributePath.slice();
                attrPath.push(attributeName);
                attributePaths.push(attrPath);
            } else {
                attrPath = attributePath.slice();
                attrPath.push(attributeName);
                attrPaths = getAttributePaths(attributeConfig[attributeName], attrPath);
                for (i = 0; i &lt; attrPaths.length; i++) {
                    attributePaths.push(attrPaths[i]);
                }
            }
        }
    }

    return attributePaths;
}

function getDevicePrintAttributePaths(attributeConfig) {
    return getAttributePaths(attributeConfig, []);
}

function hasRequiredAttributes(devicePrint, attributeConfig) {

    var attributePaths = getDevicePrintAttributePaths(attributeConfig),
        i,
        attrValue,
        attrConfig;

    for (i = 0; i &lt; attributePaths.length; i++) {

        attrValue = getValue(devicePrint, attributePaths[i]);
        attrConfig = getValue(attributeConfig, attributePaths[i]);

        if (attrConfig.required &amp;&amp; attrValue === undefined) {
            logger.warning(&quot;Device Print profile missing required attribute, &quot; + attributePaths[i]);
            return false;
        }
    }

    logger.message(&quot;device print has required attributes&quot;);
    return true;
}

function compareDevicePrintProfiles(attributeConfig, devicePrint, devicePrintProfiles, maxPenaltyPoints) {

    var attributePaths = getDevicePrintAttributePaths(attributeConfig),
        results,
        j,
        aggregatedComparisonResult,
        i,
        currentValue,
        storedValue,
        attrConfig,
        comparisonResult,
        selectedComparisonResult,
        selectedProfile,
        vals;

    results = [];
    for (j = 0; j &lt; devicePrintProfiles.length; j++) {

        aggregatedComparisonResult = new ComparisonResult();
        for (i = 0; i &lt; attributePaths.length; i++) {

            currentValue = getValue(devicePrint, attributePaths[i]);
            storedValue = getValue(devicePrintProfiles[j].devicePrint, attributePaths[i]);
            attrConfig = getValue(attributeConfig, attributePaths[i]);

            if (storedValue === null) {
                comparisonResult = new ComparisonResult(attrConfig.penaltyPoints);
            } else {
                comparisonResult = attrConfig.comparator.compare(currentValue, storedValue, attrConfig.args);
            }

            if (logger.messageEnabled()) {
                logger.message(&quot;Comparing attribute path: &quot; + attributePaths[i]
                    + &quot;, Comparison result: successful=&quot; + comparisonResult.isSuccessful() + &quot;, penaltyPoints=&quot;
                    + comparisonResult.penaltyPoints + &quot;, additionalInfoInCurrentValue=&quot;
                    + comparisonResult.additionalInfoInCurrentValue);
            }
            aggregatedComparisonResult.addComparisonResult(comparisonResult);
        }
        if (logger.messageEnabled()) {
            logger.message(&quot;Aggregated comparison result: successful=&quot;
                + aggregatedComparisonResult.isSuccessful() + &quot;, penaltyPoints=&quot;
                + aggregatedComparisonResult.penaltyPoints + &quot;, additionalInfoInCurrentValue=&quot;
                + aggregatedComparisonResult.additionalInfoInCurrentValue);
        }

        results.push({
            key: aggregatedComparisonResult,
            value: devicePrintProfiles[j]
        });
    }

    if (results.length === 0) {
        return null;
    }

    results.sort(function(a, b) {
        return ComparisonResult.compare(a.key, b.key);
    });
    selectedComparisonResult = results[0].key;
    if (logger.messageEnabled()) {
        logger.message(&quot;Selected comparison result: successful=&quot; + selectedComparisonResult.isSuccessful()
            + &quot;, penaltyPoints=&quot; + selectedComparisonResult.penaltyPoints + &quot;, additionalInfoInCurrentValue=&quot;
            + selectedComparisonResult.additionalInfoInCurrentValue);
    }

    selectedProfile = null;
    if (selectedComparisonResult.penaltyPoints &lt;= maxPenaltyPoints) {
        selectedProfile = results[0].value;
        if (logger.messageEnabled()) {
            logger.message(&quot;Selected profile: &quot; + JSON.stringify(selectedProfile) +
                &quot; with &quot; + selectedComparisonResult.penaltyPoints + &quot; penalty points&quot;);
        }
    }

    if (selectedProfile === null) {
        return false;
    }

    /* update profile */
    selectedProfile.selectionCounter = selectedProfile.selectionCounter + 1;
    selectedProfile.lastSelectedDate = new Date().getTime();
    selectedProfile.devicePrint = devicePrint;

    vals = [];
    for (i = 0; i &lt; devicePrintProfiles.length; i++) {
        vals.push(JSON.stringify(devicePrintProfiles[i]));
    }

    idRepository.setAttribute(username, &quot;devicePrintProfiles&quot;, vals);

    return true;
}

function matchDevicePrint() {

    if (!username) {
        logger.error(&quot;Username not set. Cannot compare user&apos;s device print profiles.&quot;);
        authState = FAILED;
    } else {

        if (logger.messageEnabled()) {
            logger.message(&quot;client devicePrint: &quot; + clientScriptOutputData);
        }

        var getProfiles = function () {

                function isExpiredProfile(devicePrintProfile) {
                    var expirationDate = new Date(),
                        lastSelectedDate;
                    expirationDate.setDate(expirationDate.getDate() - config.profileExpiration);

                    lastSelectedDate = new Date(devicePrintProfile.lastSelectedDate);

                    return lastSelectedDate &lt; expirationDate;
                }

                function getNotExpiredProfiles() {
                    var profile,
                        results = [],
                        profiles = idRepository.getAttribute(username, &quot;devicePrintProfiles&quot;),
                        iter;
                
                    if (profiles) {
                        iter = profiles.iterator();
                        
                        while (iter.hasNext()) {
                            profile = JSON.parse(iter.next());
                            if (!isExpiredProfile(profile)) {
                                results.push(profile);
                            }
                        }
                    }
                    if (logger.messageEnabled()) {
                        logger.message(&quot;stored non-expired profiles: &quot; + JSON.stringify(results));
                    }                    
                    return results;
                }

                return getNotExpiredProfiles();
            },
            devicePrint = JSON.parse(clientScriptOutputData),
            devicePrintProfiles = getProfiles();

        if (!hasRequiredAttributes(devicePrint, config.attributes)) {
            logger.message(&quot;devicePrint.hasRequiredAttributes: false&quot;);
            // Will fail this module but fall-through to next module. Which should be OTP.
            authState = FAILED;
        } else if (compareDevicePrintProfiles(config.attributes, devicePrint, devicePrintProfiles, config.maxPenaltyPoints)) {
            logger.message(&quot;devicePrint.hasValidProfile: true&quot;);
            authState = SUCCESS;
        } else {
            logger.message(&quot;devicePrint.hasValidProfile: false&quot;);
            sharedState.put(&apos;devicePrintProfile&apos;, JSON.stringify(devicePrint));
            // Will fail this module but fall-through to next module. Which should be OTP.
            authState = FAILED;
        }
    }
}

matchDevicePrint();
                            </Value>
                        </AttributeValuePair>
                    </SubConfiguration>
                    <SubConfiguration name="157298c0-7d31-4059-a95b-eeb08473b7e5" id="globalScript">
                        <AttributeValuePair>
                            <Attribute name="name"/>
                            <Value>Device Id (Match) - Client Side</Value>
                        </AttributeValuePair>
                        <AttributeValuePair>
                            <Attribute name="description"/>
                            <Value>Default global script for client side Device Id (Match) Authentication Module</Value>
                        </AttributeValuePair>
                        <AttributeValuePair>
                            <Attribute name="context"/>
                            <Value>AUTHENTICATION_CLIENT_SIDE</Value>
                        </AttributeValuePair>
                        <AttributeValuePair>
                            <Attribute name="script"/>
                            <Value>
var fontDetector = (function () {
    /**
     * JavaScript code to detect available availability of a
     * particular font in a browser using JavaScript and CSS.
     *
     * Author : Lalit Patel
     * Website: http://www.lalit.org/lab/javascript-css-font-detect/
     * License: Apache Software License 2.0
     *          http://www.apache.org/licenses/LICENSE-2.0
     * Version: 0.15 (21 Sep 2009)
     *          Changed comparision font to default from sans-default-default,
     *          as in FF3.0 font of child element didn&apos;t fallback
     *          to parent element if the font is missing.
     * Version: 0.2 (04 Mar 2012)
     *          Comparing font against all the 3 generic font families ie,
     *          &apos;monospace&apos;, &apos;sans-serif&apos; and &apos;sans&apos;. If it doesn&apos;t match all 3
     *          then that font is 100% not available in the system
     * Version: 0.3 (24 Mar 2012)
     *          Replaced sans with serif in the list of baseFonts
     */
    /*
     * Portions Copyrighted 2013 ForgeRock AS.
     */
    var detector = {}, baseFonts, testString, testSize, h, s, defaultWidth = {}, defaultHeight = {}, index;

    // a font will be compared against all the three default fonts.
    // and if it doesn&apos;t match all 3 then that font is not available.
    baseFonts = [&apos;monospace&apos;, &apos;sans-serif&apos;, &apos;serif&apos;];

    //we use m or w because these two characters take up the maximum width.
    // And we use a LLi so that the same matching fonts can get separated
    testString = &quot;mmmmmmmmmmlli&quot;;

    //we test using 72px font size, we may use any size. I guess larger the better.
    testSize = &apos;72px&apos;;

    h = document.getElementsByTagName(&quot;body&quot;)[0];

    // create a SPAN in the document to get the width of the text we use to test
    s = document.createElement(&quot;span&quot;);
    s.style.fontSize = testSize;
    s.innerHTML = testString;
    for (index in baseFonts) {
        //get the default width for the three base fonts
        s.style.fontFamily = baseFonts[index];
        h.appendChild(s);
        defaultWidth[baseFonts[index]] = s.offsetWidth; //width for the default font
        defaultHeight[baseFonts[index]] = s.offsetHeight; //height for the defualt font
        h.removeChild(s);
    }

    detector.detect = function(font) {
        var detected = false, index, matched;
        for (index in baseFonts) {
            s.style.fontFamily = font + &apos;,&apos; + baseFonts[index]; // name of the font along with the base font for fallback.
            h.appendChild(s);
            matched = (s.offsetWidth !== defaultWidth[baseFonts[index]] || s.offsetHeight !== defaultHeight[baseFonts[index]]);
            h.removeChild(s);
            detected = detected || matched;
        }
        return detected;
    };

    return detector;
}());
/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 *
 * Copyright (c) 2009 Sun Microsystems Inc. All Rights Reserved
 *
 * The contents of this file are subject to the terms
 * of the Common Development and Distribution License
 * (the License). You may not use this file except in
 * compliance with the License.
 *
 * You can obtain a copy of the License at
 * https://opensso.dev.java.net/public/CDDLv1.0.html or
 * opensso/legal/CDDLv1.0.txt
 * See the License for the specific language governing
 * permission and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL
 * Header Notice in each file and include the License file
 * at opensso/legal/CDDLv1.0.txt.
 * If applicable, add the following below the CDDL Header,
 * with the fields enclosed by brackets [] replaced by
 * your own identifying information:
 * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
 *
 */
/*
 * Portions Copyrighted 2013 Syntegrity.
 * Portions Copyrighted 2013-2014 ForgeRock AS.
 */

var collectScreenInfo = function () {
        var screenInfo = {};
        if (screen) {
            if (screen.width) {
                screenInfo.screenWidth = screen.width;
            }

            if (screen.height) {
                screenInfo.screenHeight = screen.height;
            }

            if (screen.pixelDepth) {
                screenInfo.screenColourDepth = screen.pixelDepth;
            }
        } else {
            console.warn(&quot;Cannot collect screen information. screen is not defined.&quot;);
        }
        return screenInfo;
    },
    collectTimezoneInfo = function () {
        var timezoneInfo =  {}, offset = new Date().getTimezoneOffset();

        if (offset) {
            timezoneInfo.timezone = offset;
        } else {
            console.warn(&quot;Cannot collect timezone information. timezone is not defined.&quot;);
        }

        return timezoneInfo;
    },
    collectBrowserPluginsInfo = function () {

        if (navigator &amp;&amp; navigator.plugins) {
            var pluginsInfo = {}, i, plugins = navigator.plugins;
            pluginsInfo.installedPlugins = &quot;&quot;;

            for (i = 0; i &lt; plugins.length; i++) {
                pluginsInfo.installedPlugins = pluginsInfo.installedPlugins + plugins[i].filename + &quot;;&quot;;
            }

            return pluginsInfo;
        } else {
            console.warn(&quot;Cannot collect browser plugin information. navigator.plugins is not defined.&quot;);
            return {};
        }

    },
// Getting geolocation takes some time and is done asynchronously, hence need a callback which is called once geolocation is retrieved.
    collectGeolocationInfo = function (callback) {
        var geolocationInfo = {},
            successCallback = function(position) {
                geolocationInfo.longitude = position.coords.longitude;
                geolocationInfo.latitude = position.coords.latitude;
                callback(geolocationInfo);
            }, errorCallback = function(error) {
                console.warn(&quot;Cannot collect geolocation information. &quot; + error.code + &quot;: &quot; + error.message);
                callback(geolocationInfo);
            };
        if (navigator &amp;&amp; navigator.geolocation) {
            // NB: If user chooses &apos;Not now&apos; on Firefox neither callback gets called
            //     https://bugzilla.mozilla.org/show_bug.cgi?id=675533
            navigator.geolocation.getCurrentPosition(successCallback, errorCallback);
        } else {
            console.warn(&quot;Cannot collect geolocation information. navigator.geolocation is not defined.&quot;);
            callback(geolocationInfo);
        }
    },
    collectBrowserFontsInfo = function () {
        var fontsInfo = {}, i, fontsList = [&quot;cursive&quot;,&quot;monospace&quot;,&quot;serif&quot;,&quot;sans-serif&quot;,&quot;fantasy&quot;,&quot;default&quot;,&quot;Arial&quot;,&quot;Arial Black&quot;,
            &quot;Arial Narrow&quot;,&quot;Arial Rounded MT Bold&quot;,&quot;Bookman Old Style&quot;,&quot;Bradley Hand ITC&quot;,&quot;Century&quot;,&quot;Century Gothic&quot;,
            &quot;Comic Sans MS&quot;,&quot;Courier&quot;,&quot;Courier New&quot;,&quot;Georgia&quot;,&quot;Gentium&quot;,&quot;Impact&quot;,&quot;King&quot;,&quot;Lucida Console&quot;,&quot;Lalit&quot;,
            &quot;Modena&quot;,&quot;Monotype Corsiva&quot;,&quot;Papyrus&quot;,&quot;Tahoma&quot;,&quot;TeX&quot;,&quot;Times&quot;,&quot;Times New Roman&quot;,&quot;Trebuchet MS&quot;,&quot;Verdana&quot;,
            &quot;Verona&quot;];
        fontsInfo.installedFonts = &quot;&quot;;

        for (i = 0; i &lt; fontsList.length; i++) {
            if (fontDetector.detect(fontsList[i])) {
                fontsInfo.installedFonts = fontsInfo.installedFonts + fontsList[i] + &quot;;&quot;;
            }
        }
        return fontsInfo;
    },
    devicePrint = {};

devicePrint.screen = collectScreenInfo();
devicePrint.timezone = collectTimezoneInfo();
devicePrint.plugins = collectBrowserPluginsInfo();
devicePrint.fonts = collectBrowserFontsInfo();

if (navigator.userAgent) {
    devicePrint.userAgent = navigator.userAgent;
}
if (navigator.appName) {
    devicePrint.appName = navigator.appName;
}
if (navigator.appCodeName) {
    devicePrint.appCodeName = navigator.appCodeName;
}
if (navigator.appVersion) {
    devicePrint.appVersion = navigator.appVersion;
}
if (navigator.appMinorVersion) {
    devicePrint.appMinorVersion = navigator.appMinorVersion;
}
if (navigator.buildID) {
    devicePrint.buildID = navigator.buildID;
}
if (navigator.platform) {
    devicePrint.platform = navigator.platform;
}
if (navigator.cpuClass) {
    devicePrint.cpuClass = navigator.cpuClass;
}
if (navigator.oscpu) {
    devicePrint.oscpu = navigator.oscpu;
}
if (navigator.product) {
    devicePrint.product = navigator.product;
}
if (navigator.productSub) {
    devicePrint.productSub = navigator.productSub;
}
if (navigator.vendor) {
    devicePrint.vendor = navigator.vendor;
}
if (navigator.vendorSub) {
    devicePrint.vendorSub = navigator.vendorSub;
}
if (navigator.language) {
    devicePrint.language = navigator.language;
}
if (navigator.userLanguage) {
    devicePrint.userLanguage = navigator.userLanguage;
}
if (navigator.browserLanguage) {
    devicePrint.browserLanguage = navigator.browserLanguage;
}
if (navigator.systemLanguage) {
    devicePrint.systemLanguage = navigator.systemLanguage;
}

// Attempt to collect geo-location information and return this with the data collected so far.
// Otherwise, if geo-location fails or takes longer than 30 seconds, auto-submit the data collected so far.
autoSubmitDelay = 30000;
output.value = JSON.stringify(devicePrint);
collectGeolocationInfo(function(geolocationInfo) {
    devicePrint.geolocation = geolocationInfo;
    output.value = JSON.stringify(devicePrint);
    submit();
});
                            </Value>
                        </AttributeValuePair>
                    </SubConfiguration>
                    <SubConfiguration name="36863ffb-40ec-48b9-94b1-9a99f71cc3b5" id="globalScript">
                        <AttributeValuePair>
                            <Attribute name="name"/>
                            <Value>OIDC Claims Script</Value>
                        </AttributeValuePair>
                        <AttributeValuePair>
                            <Attribute name="description"/>
                            <Value>Default global script for OIDC claims</Value>
                        </AttributeValuePair>
                        <AttributeValuePair>
                            <Attribute name="context"/>
                            <Value>OIDC_CLAIMS</Value>
                        </AttributeValuePair>
                        <AttributeValuePair>
                            <Attribute name="language"/>
                            <Value>GROOVY</Value>
                        </AttributeValuePair>
                        <AttributeValuePair>
                            <Attribute name="script"/>
                            <Value>
/*
* The contents of this file are subject to the terms of the Common Development and
* Distribution License (the License). You may not use this file except in compliance with the
* License.
*
* You can obtain a copy of the License at legal/CDDLv1.0.txt. See the License for the
* specific language governing permission and limitations under the License.
*
* When distributing Covered Software, include this CDDL Header Notice in each file and include
* the License file at legal/CDDLv1.0.txt. If applicable, add the following below the CDDL
* Header, with the fields enclosed by brackets [] replaced by your own identifying
* information: &quot;Portions copyright [year] [name of copyright owner]&quot;.
*
* Copyright 2014-2016 ForgeRock AS.
*/
import com.iplanet.sso.SSOException
import com.sun.identity.idm.IdRepoException
import org.forgerock.oauth2.core.UserInfoClaims

/*
* Defined variables:
* logger - always presents, the &quot;OAuth2Provider&quot; debug logger instance
* claims - always present, default server provided claims
* session - present if the request contains the session cookie, the user&apos;s session object
* identity - always present, the identity of the resource owner
* scopes - always present, the requested scopes
* requestedClaims - Map&lt;String, Set&lt;String&gt;&gt;
*                  always present, not empty if the request contains a claims parameter and server has enabled
*                  claims_parameter_supported, map of requested claims to possible values, otherwise empty,
*                  requested claims with no requested values will have a key but no value in the map. A key with
*                  a single value in its Set indicates this is the only value that should be returned.
* Required to return a Map of claims to be added to the id_token claims
*
* Expected return value structure:
* UserInfoClaims {
*    Map&lt;String, Object&gt; values; // The values of the claims for the user information
*    Map&lt;String, List&lt;String&gt;&gt; compositeScopes; // Mapping of scope name to a list of claim names.
* }
*/

// user session not guaranteed to be present
boolean sessionPresent = session != null

def fromSet = { claim, attr -&gt;
    if (attr != null &amp;&amp; attr.size() == 1){
        attr.iterator().next()
    } else if (attr != null &amp;&amp; attr.size() &gt; 1){
        attr
    } else if (logger.warningEnabled()) {
        logger.warning(&quot;OpenAMScopeValidator.getUserInfo(): Got an empty result for claim=$claim&quot;);
    }
}

attributeRetriever = { attribute, claim, identity, requested -&gt;
    if (requested == null || requested.isEmpty()) {
        fromSet(claim, identity.getAttribute(attribute))
    } else if (requested.size() == 1) {
        requested.iterator().next()
    } else {
        throw new RuntimeException(&quot;No selection logic for $claim defined. Values: $requested&quot;)
    }
}

// [ {claim}: {attribute retriever}, ... ]
claimAttributes = [
        &quot;email&quot;: attributeRetriever.curry(&quot;mail&quot;),
        &quot;address&quot;: { claim, identity, requested -&gt; [ &quot;formatted&quot; : attributeRetriever(&quot;postaladdress&quot;, claim, identity, requested) ] },
        &quot;phone_number&quot;: attributeRetriever.curry(&quot;telephonenumber&quot;),
        &quot;given_name&quot;: attributeRetriever.curry(&quot;givenname&quot;),
        &quot;zoneinfo&quot;: attributeRetriever.curry(&quot;preferredtimezone&quot;),
        &quot;family_name&quot;: attributeRetriever.curry(&quot;sn&quot;),
        &quot;locale&quot;: attributeRetriever.curry(&quot;preferredlocale&quot;),
        &quot;name&quot;: attributeRetriever.curry(&quot;cn&quot;)
]

// {scope}: [ {claim}, ... ]
scopeClaimsMap = [
        &quot;email&quot;: [ &quot;email&quot; ],
        &quot;address&quot;: [ &quot;address&quot; ],
        &quot;phone&quot;: [ &quot;phone_number&quot; ],
        &quot;profile&quot;: [ &quot;given_name&quot;, &quot;zoneinfo&quot;, &quot;family_name&quot;, &quot;locale&quot;, &quot;name&quot; ]
]

if (logger.messageEnabled()) {
    scopes.findAll { s -&gt; !(&quot;openid&quot;.equals(s) || scopeClaimsMap.containsKey(s)) }.each { s -&gt;
        logger.message(&quot;OpenAMScopeValidator.getUserInfo()::Message: scope not bound to claims: $s&quot;)
    }
}

def computeClaim = { claim, requestedValues -&gt;
    try {
        [ claim, claimAttributes.get(claim)(claim, identity, requestedValues) ]
    } catch (IdRepoException e) {
        if (logger.warningEnabled()) {
            logger.warning(&quot;OpenAMScopeValidator.getUserInfo(): Unable to retrieve attribute=$attribute&quot;, e);
        }
    } catch (SSOException e) {
        if (logger.warningEnabled()) {
            logger.warning(&quot;OpenAMScopeValidator.getUserInfo(): Unable to retrieve attribute=$attribute&quot;, e);
        }
    }
}

def computedClaims = scopes.findAll { s -&gt; !&quot;openid&quot;.equals(s) &amp;&amp; scopeClaimsMap.containsKey(s) }.inject(claims) { map, s -&gt;
    scopeClaims = scopeClaimsMap.get(s)
    map &lt;&lt; scopeClaims.findAll { c -&gt; !requestedClaims.containsKey(c) }.collectEntries([:]) { claim -&gt; computeClaim(claim, null) }
}.findAll { map -&gt; map.value != null } &lt;&lt; requestedClaims.collectEntries([:]) { claim, requestedValue -&gt;
    computeClaim(claim, requestedValue)
}

def compositeScopes = scopeClaimsMap.findAll { scope -&gt;
    scopes.contains(scope.key)
}

return new UserInfoClaims((Map)computedClaims, (Map)compositeScopes)
                            </Value>
                        </AttributeValuePair>
                    </SubConfiguration>
                </SubConfiguration>
            </GlobalConfiguration>
        </Configuration>

    </Service>
</ServicesConfiguration>
